// mksyscall_windows.pl fetcp_api.go
// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT

package fetcp

import "unsafe"
import "syscall"

var (
	modfetcp = syscall.NewLazyDLL("fetcp.dll")

	procFETCP_Connect = modfetcp.NewProc("FETCP_Connect")
	procFETCP_DisConnect = modfetcp.NewProc("FETCP_DisConnect")
	procFETCP_Detect = modfetcp.NewProc("FETCP_Detect")
	procFETCP_GetSocketState = modfetcp.NewProc("FETCP_GetSocketState")
	procFETCP_GetSocketList = modfetcp.NewProc("FETCP_GetSocketList")
	procFETCP_GetDLLVersion = modfetcp.NewProc("FETCP_GetDLLVersion")
	procFETCP_GetErrorText = modfetcp.NewProc("FETCP_GetErrorText")
	procFETCP_GetLastError = modfetcp.NewProc("FETCP_GetLastError")
	procFETCP_GetSocketHnd = modfetcp.NewProc("FETCP_GetSocketHnd")
	procFETCP_GetSocketPara = modfetcp.NewProc("FETCP_GetSocketPara")
	procFETCP_SetSocketPara = modfetcp.NewProc("FETCP_SetSocketPara")
	procFETCP_Transceive = modfetcp.NewProc("FETCP_Transceive")
	procFETCP_Transmit = modfetcp.NewProc("FETCP_Transmit")
	procFETCP_Receive = modfetcp.NewProc("FETCP_Receive")

)

func FETCP_Connect(cHostAdr *byte, iPortNr uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_Connect.Addr(), 2, uintptr(unsafe.Pointer(cHostAdr)), uintptr(iPortNr), 0)
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_Disconnect(iSocketHnd uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_DisConnect.Addr(), 1, uintptr(iSocketHnd), 0, 0)
	result = uint32(r0)
	if result != 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_Detect(cHostAdr *byte, iPortNr uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_Detect.Addr(), 2, uintptr(unsafe.Pointer(cHostAdr)), uintptr(iPortNr), 0)
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_GetSocketState(cHostAdr *byte, iPortNr uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_GetSocketState.Addr(), 2, uintptr(unsafe.Pointer(cHostAdr)), uintptr(iPortNr), 0)
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_GetSocketList(iNext uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_GetSocketList.Addr(), 1, uintptr(iNext), 0, 0)
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_GetDLLVersion(cVersion *byte) {
	syscall.Syscall(procFETCP_GetDLLVersion.Addr(), 1, uintptr(unsafe.Pointer(cVersion)), 0, 0)
	return
}

func FETCP_GetErrorText(iErrorCode uint32, cErrorText *byte) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_GetErrorText.Addr(), 2, uintptr(iErrorCode), uintptr(unsafe.Pointer(cErrorText)), 0)
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_GetLastError(iSocketHnd uint32, iErrorCode *uint32, cErrorText *byte) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_GetLastError.Addr(), 3, uintptr(iSocketHnd), uintptr(unsafe.Pointer(iErrorCode)), uintptr(unsafe.Pointer(cErrorText)))
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_GetSocketHnd(cHostAdr *byte, iPortNr uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_GetSocketHnd.Addr(), 2, uintptr(unsafe.Pointer(cHostAdr)), uintptr(iPortNr), 0)
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_GetSocketPara(iSocketHnd uint32, cPara *byte, cValue *byte) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_GetSocketPara.Addr(), 3, uintptr(iSocketHnd), uintptr(unsafe.Pointer(cPara)), uintptr(unsafe.Pointer(cValue)))
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_SetSocketPara(iSocketHnd uint32, cPara *byte, cValue *byte) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_SetSocketPara.Addr(), 3, uintptr(iSocketHnd), uintptr(unsafe.Pointer(cPara)), uintptr(unsafe.Pointer(cValue)))
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_Transceive(iSocketHnd uint32, cSendProt *byte, iSendLen uint32, recvBuf *byte, recvBufLen uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall6(procFETCP_Transceive.Addr(), 5, uintptr(iSocketHnd), uintptr(unsafe.Pointer(cSendProt)), uintptr(iSendLen), uintptr(unsafe.Pointer(recvBuf)), uintptr(recvBufLen), 0)
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_Transmit(iSocketHnd uint32, cSendProt *byte, iSendLen uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_Transmit.Addr(), 3, uintptr(iSocketHnd), uintptr(unsafe.Pointer(cSendProt)), uintptr(iSendLen))
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func FETCP_Receive(iSocketHnd uint32, cRecProt *byte, cRecLec uint32) (result uint32, err error) {
	r0, _, e1 := syscall.Syscall(procFETCP_Receive.Addr(), 3, uintptr(iSocketHnd), uintptr(unsafe.Pointer(cRecProt)), uintptr(cRecLec))
	result = uint32(r0)
	if result <0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}


